{"ast":null,"code":"/**\n * @license lucide v0.469.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createElement from './createElement.js';\nconst getAttrs = element => Array.from(element.attributes).reduce((attrs, attr) => {\n  attrs[attr.name] = attr.value;\n  return attrs;\n}, {});\nconst getClassNames = attrs => {\n  if (typeof attrs === \"string\") return attrs;\n  if (!attrs || !attrs.class) return \"\";\n  if (attrs.class && typeof attrs.class === \"string\") {\n    return attrs.class.split(\" \");\n  }\n  if (attrs.class && Array.isArray(attrs.class)) {\n    return attrs.class;\n  }\n  return \"\";\n};\nconst combineClassNames = arrayOfClassnames => {\n  const classNameArray = arrayOfClassnames.flatMap(getClassNames);\n  return classNameArray.map(classItem => classItem.trim()).filter(Boolean).filter((value, index, self) => self.indexOf(value) === index).join(\" \");\n};\nconst toPascalCase = string => string.replace(/(\\w)(\\w*)(_|-|\\s*)/g, (g0, g1, g2) => g1.toUpperCase() + g2.toLowerCase());\nconst replaceElement = (element, {\n  nameAttr,\n  icons,\n  attrs\n}) => {\n  const iconName = element.getAttribute(nameAttr);\n  if (iconName == null) return;\n  const ComponentName = toPascalCase(iconName);\n  const iconNode = icons[ComponentName];\n  if (!iconNode) {\n    return console.warn(`${element.outerHTML} icon name was not found in the provided icons object.`);\n  }\n  const elementAttrs = getAttrs(element);\n  const [tag, iconAttributes, children] = iconNode;\n  const iconAttrs = {\n    ...iconAttributes,\n    \"data-lucide\": iconName,\n    ...attrs,\n    ...elementAttrs\n  };\n  const classNames = combineClassNames([\"lucide\", `lucide-${iconName}`, elementAttrs, attrs]);\n  if (classNames) {\n    Object.assign(iconAttrs, {\n      class: classNames\n    });\n  }\n  const svgElement = createElement([tag, iconAttrs, children]);\n  return element.parentNode?.replaceChild(svgElement, element);\n};\nexport { combineClassNames, replaceElement as default, getAttrs, getClassNames };","map":{"version":3,"names":["getAttrs","element","Array","from","attributes","reduce","attrs","attr","name","value","getClassNames","class","split","isArray","combineClassNames","arrayOfClassnames","classNameArray","flatMap","map","classItem","trim","filter","Boolean","index","self","indexOf","join","toPascalCase","string","replace","g0","g1","g2","toUpperCase","toLowerCase","replaceElement","nameAttr","icons","iconName","getAttribute","ComponentName","iconNode","console","warn","outerHTML","elementAttrs","tag","iconAttributes","children","iconAttrs","classNames","Object","assign","svgElement","createElement","parentNode","replaceChild"],"sources":["/Users/busha/Desktop/rockview/node_modules/lucide/src/replaceElement.ts"],"sourcesContent":["import createElement from './createElement';\nimport { Icons } from './types';\n\nexport type CustomAttrs = { [attr: string]: any };\n\n/**\n * Get the attributes of an HTML element.\n * @param {HTMLElement} element\n * @returns {Object}\n */\nexport const getAttrs = (element: Element): Record<string, string> =>\n  Array.from(element.attributes).reduce<Record<string, string>>((attrs, attr) => {\n    attrs[attr.name] = attr.value;\n    return attrs;\n  }, {});\n\n/**\n * Gets the classNames of an attributes Object.\n * @param {Object} attrs\n * @returns {Array}\n */\nexport const getClassNames = (attrs: Record<string, string> | string): string | string[] => {\n  if (typeof attrs === 'string') return attrs;\n  if (!attrs || !attrs.class) return '';\n  if (attrs.class && typeof attrs.class === 'string') {\n    return attrs.class.split(' ');\n  }\n  if (attrs.class && Array.isArray(attrs.class)) {\n    return attrs.class;\n  }\n  return '';\n};\n\n/**\n * Combines the classNames of array of classNames to a String\n * @param {array} arrayOfClassnames\n * @returns {string}\n */\nexport const combineClassNames = (arrayOfClassnames: (string | Record<string, string>)[]) => {\n  const classNameArray = arrayOfClassnames.flatMap(getClassNames);\n\n  return classNameArray\n    .map((classItem) => classItem.trim())\n    .filter(Boolean)\n    .filter((value, index, self) => self.indexOf(value) === index)\n    .join(' ');\n};\n\nconst toPascalCase = (string: string): string =>\n  string.replace(/(\\w)(\\w*)(_|-|\\s*)/g, (g0, g1, g2) => g1.toUpperCase() + g2.toLowerCase());\n\ninterface ReplaceElementOptions {\n  nameAttr: string;\n  icons: Icons;\n  attrs: Record<string, string>;\n}\n\n/**\n * ReplaceElement, replaces the given element with the created icon.\n * @param {HTMLElement} element\n * @param {{ nameAttr: string, icons: object, attrs: object }} options: { nameAttr, icons, attrs }\n * @returns {Function}\n */\nconst replaceElement = (element: Element, { nameAttr, icons, attrs }: ReplaceElementOptions) => {\n  const iconName = element.getAttribute(nameAttr);\n\n  if (iconName == null) return;\n\n  const ComponentName = toPascalCase(iconName);\n\n  const iconNode = icons[ComponentName];\n\n  if (!iconNode) {\n    return console.warn(\n      `${element.outerHTML} icon name was not found in the provided icons object.`,\n    );\n  }\n\n  const elementAttrs = getAttrs(element);\n  const [tag, iconAttributes, children] = iconNode;\n\n  const iconAttrs = {\n    ...iconAttributes,\n    'data-lucide': iconName,\n    ...attrs,\n    ...elementAttrs,\n  };\n\n  const classNames = combineClassNames(['lucide', `lucide-${iconName}`, elementAttrs, attrs]);\n\n  if (classNames) {\n    Object.assign(iconAttrs, {\n      class: classNames,\n    });\n  }\n\n  const svgElement = createElement([tag, iconAttrs, children]);\n\n  return element.parentNode?.replaceChild(svgElement, element);\n};\n\nexport default replaceElement;\n"],"mappings":";;;;;;;;AAUa,MAAAA,QAAA,GAAYC,OAAA,IACvBC,KAAM,CAAAC,IAAA,CAAKF,OAAQ,CAAAG,UAAU,CAAE,CAAAC,MAAA,CAA+B,CAACC,KAAA,EAAOC,IAAS;EACvED,KAAA,CAAAC,IAAA,CAAKC,IAAI,IAAID,IAAK,CAAAE,KAAA;EACjB,OAAAH,KAAA;AACT,GAAG,EAAE;AAOM,MAAAI,aAAA,GAAiBJ,KAA8D;EAC1F,IAAI,OAAOA,KAAU,eAAiB,OAAAA,KAAA;EAClC,KAACA,KAAS,KAACA,KAAM,CAAAK,KAAA,EAAc;EACnC,IAAIL,KAAM,CAAAK,KAAA,IAAS,OAAOL,KAAA,CAAMK,KAAA,KAAU,QAAU;IAC3C,OAAAL,KAAA,CAAMK,KAAM,CAAAC,KAAA,CAAM,GAAG;EAC9B;EACA,IAAIN,KAAA,CAAMK,KAAS,IAAAT,KAAA,CAAMW,OAAQ,CAAAP,KAAA,CAAMK,KAAK,CAAG;IAC7C,OAAOL,KAAM,CAAAK,KAAA;EACf;EACO;AACT;AAOa,MAAAG,iBAAA,GAAqBC,iBAA2D;EACrF,MAAAC,cAAA,GAAiBD,iBAAkB,CAAAE,OAAA,CAAQP,aAAa;EAEvD,OAAAM,cAAA,CACJE,GAAA,CAAKC,SAAA,IAAcA,SAAA,CAAUC,IAAK,EAAC,CACnC,CAAAC,MAAA,CAAOC,OAAO,EACdD,MAAA,CAAO,CAACZ,KAAA,EAAOc,KAAO,EAAAC,IAAA,KAASA,IAAK,CAAAC,OAAA,CAAQhB,KAAK,CAAM,KAAAc,KAAK,CAC5D,CAAAG,IAAA,CAAK,GAAG;AACb;AAEA,MAAMC,YAAe,GAACC,MACpB,IAAAA,MAAA,CAAOC,OAAA,CAAQ,qBAAuB,GAACC,EAAI,EAAAC,EAAA,EAAIC,EAAA,KAAOD,EAAG,CAAAE,WAAA,EAAgB,GAAAD,EAAA,CAAGE,WAAA,CAAa;AAc3F,MAAMC,cAAA,GAAiBA,CAAClC,OAAA,EAAkB;EAAEmC,QAAU;EAAAC,KAAA;EAAO/B;AAAA,CAAmC;EACxF,MAAAgC,QAAA,GAAWrC,OAAQ,CAAAsC,YAAA,CAAaH,QAAQ;EAE9C,IAAIE,QAAY,UAAM;EAEhB,MAAAE,aAAA,GAAgBb,YAAA,CAAaW,QAAQ;EAErC,MAAAG,QAAA,GAAWJ,KAAA,CAAMG,aAAa;EAEpC,IAAI,CAACC,QAAU;IACb,OAAOC,OAAQ,CAAAC,IAAA,CACb,GAAG1C,OAAA,CAAQ2C,SAAS,yDACtB;EACF;EAEM,MAAAC,YAAA,GAAe7C,QAAA,CAASC,OAAO;EACrC,MAAM,CAAC6C,GAAA,EAAKC,cAAgB,EAAAC,QAAQ,CAAI,GAAAP,QAAA;EAExC,MAAMQ,SAAY;IAChB,GAAGF,cAAA;IACH,aAAe,EAAAT,QAAA;IACf,GAAGhC,KAAA;IACH,GAAGuC;EAAA,CACL;EAEM,MAAAK,UAAA,GAAapC,iBAAA,CAAkB,CAAC,UAAU,UAAUwB,QAAQ,IAAIO,YAAc,EAAAvC,KAAK,CAAC;EAE1F,IAAI4C,UAAY;IACdC,MAAA,CAAOC,MAAA,CAAOH,SAAW;MACvBtC,KAAO,EAAAuC;IAAA,CACR;EACH;EAEA,MAAMG,UAAA,GAAaC,aAAc,EAACR,GAAK,EAAAG,SAAA,EAAWD,QAAQ,CAAC;EAE3D,OAAO/C,OAAQ,CAAAsD,UAAA,EAAYC,YAAa,CAAAH,UAAA,EAAYpD,OAAO;AAC7D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}